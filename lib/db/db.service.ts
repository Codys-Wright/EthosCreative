import { Effect as E, Layer } from "effect";
import { db } from "@/lib/db";
import * as schema from "./schema";
import { eq, and, or, sql } from "drizzle-orm";
import * as serverDb from "./server-db";
import { DatabaseError } from "@/features/global/lib/errors/base-errors";
import { randomUUID } from "crypto";

// Helper to check if a field should be handled by Drizzle defaults
const isAutoGeneratedField = (fieldName: string): boolean => {
  // Common auto-generated field names
  const autoFields = [
    'id', 
    'createdAt', 'created_at', 
    'updatedAt', 'updated_at',
    'deletedAt', 'deleted_at'
  ];
  return autoFields.includes(fieldName);
};

// Helper function to prepare data for insertion by filtering out auto-generated fields
const prepareDataForInsert = (tableName: keyof typeof schema, data: any): any => {
  // Don't try to set auto-generated fields, let Drizzle handle them
  const prepared: Record<string, any> = {};
  
  // Only include non-auto-generated fields
  Object.keys(data).forEach(key => {
    if (!isAutoGeneratedField(key) || data[key] !== null) {
      prepared[key] = data[key];
    }
  });
  
  console.log(`Prepared data for ${tableName} (letting Drizzle handle defaults):`, prepared);
  return prepared;
};

/**
 * A service that provides database access with Effect-based error handling
 * This wraps the server-side database functions to be used as a dependency in other services
 */
export class Database extends E.Service<Database>()("Database", {
  effect: E.sync(() => ({
    /**
     * Find many records from a table
     */
    findMany: <T>(
      tableName: keyof typeof schema, 
      options?: { 
        where?: any, 
        orderBy?: any,
        limit?: number,
        offset?: number
      }
    ) => 
      E.tryPromise({
        try: () => serverDb.findMany<T>(tableName, options),
        catch: (error) => 
          new DatabaseError({
            message: `Failed to fetch ${String(tableName)}`,
            operation: "select",
            entity: String(tableName),
            cause: error
          })
      }).pipe(
        E.withSpan(`Database.findMany.${String(tableName)}`),
        E.tap(() => E.annotateCurrentSpan("db.table", String(tableName))),
        E.tap(() => E.annotateCurrentSpan("db.operation", "findMany"))
      ),

    /**
     * Find a single record from a table
     */
    findFirst: <T>(
      tableName: keyof typeof schema, 
      options?: { 
        where?: any,
        orderBy?: any
      }
    ) => 
      E.tryPromise({
        try: () => serverDb.findFirst<T>(tableName, options),
        catch: (error) => 
          new DatabaseError({
            message: `Failed to fetch ${String(tableName)}`,
            operation: "select",
            entity: String(tableName),
            cause: error
          })
      }).pipe(
        E.withSpan(`Database.findFirst.${String(tableName)}`),
        E.tap(() => E.annotateCurrentSpan("db.table", String(tableName))),
        E.tap(() => E.annotateCurrentSpan("db.operation", "findFirst"))
      ),

    /**
     * Find a record by ID
     */
    findById: <T>(
      tableName: keyof typeof schema, 
      id: string
    ) => 
      E.tryPromise({
        try: () => serverDb.findById<T>(tableName, id),
        catch: (error) => 
          new DatabaseError({
            message: `Failed to fetch ${String(tableName)} with ID ${id}`,
            operation: "select",
            entity: String(tableName),
            cause: error
          })
      }).pipe(
        E.withSpan(`Database.findById.${String(tableName)}`),
        E.tap(() => E.annotateCurrentSpan("db.table", String(tableName))),
        E.tap(() => E.annotateCurrentSpan("db.operation", "findById")),
        E.tap(() => E.annotateCurrentSpan("db.id", id))
      ),

    /**
     * Insert a record into a table
     */
    insert: <T>(
      tableName: keyof typeof schema, 
      data: any
    ) => 
      E.tryPromise({
        try: () => {
          // Prepare data by filtering out auto-generated fields
          const preparedData = prepareDataForInsert(tableName, data);
          console.log(`Inserting into ${tableName}, letting Drizzle handle defaults:`, preparedData);
          return serverDb.insert<T>(tableName, preparedData);
        },
        catch: (error) => 
          new DatabaseError({
            message: `Failed to create ${String(tableName)}`,
            operation: "insert",
            entity: String(tableName),
            cause: error
          })
      }).pipe(
        E.withSpan(`Database.insert.${String(tableName)}`),
        E.tap(() => E.annotateCurrentSpan("db.table", String(tableName))),
        E.tap(() => E.annotateCurrentSpan("db.operation", "insert")),
        E.tap(() => E.annotateCurrentSpan("db.fields", Object.keys(data).join(",")))
      ),

    /**
     * Update a record in a table
     */
    update: <T>(
      tableName: keyof typeof schema, 
      id: string, 
      data: any
    ) => 
      E.tryPromise({
        try: () => {
          // Filter out auto-generated fields from updates
          const updateData: Record<string, any> = {};
          
          // Only include non-auto timestamp fields
          Object.keys(data).forEach(key => {
            // Include all non-auto fields or explicitly provided auto fields
            if (!isAutoGeneratedField(key) || (key !== 'createdAt' && key !== 'created_at')) {
              updateData[key] = data[key];
            }
          });
          
          console.log(`Updating ${tableName} with ID ${id}, letting Drizzle handle timestamps:`, updateData);
          return serverDb.update<T>(tableName, id, updateData);
        },
        catch: (error) => 
          new DatabaseError({
            message: `Failed to update ${String(tableName)} with ID ${id}`,
            operation: "update",
            entity: String(tableName),
            cause: error
          })
      }).pipe(
        E.withSpan(`Database.update.${String(tableName)}`),
        E.tap(() => E.annotateCurrentSpan("db.table", String(tableName))),
        E.tap(() => E.annotateCurrentSpan("db.operation", "update")),
        E.tap(() => E.annotateCurrentSpan("db.id", id)),
        E.tap(() => E.annotateCurrentSpan("db.fields", Object.keys(data).join(",")))
      ),

    /**
     * Delete a record from a table
     */
    delete: <T>(
      tableName: keyof typeof schema, 
      id: string
    ) => 
      E.tryPromise({
        try: () => serverDb.deleteRecord<T>(tableName, id),
        catch: (error) => 
          new DatabaseError({
            message: `Failed to delete ${String(tableName)} with ID ${id}`,
            operation: "delete",
            entity: String(tableName),
            cause: error
          })
      }).pipe(
        E.withSpan(`Database.delete.${String(tableName)}`),
        E.tap(() => E.annotateCurrentSpan("db.table", String(tableName))),
        E.tap(() => E.annotateCurrentSpan("db.operation", "delete")),
        E.tap(() => E.annotateCurrentSpan("db.id", id))
      ),

    /**
     * Execute a custom query
     */
    execute: <T>(
      queryFn: (dbInstance: any) => Promise<T>,
      options?: {
        operation?: string;
        entity?: string;
      }
    ) => 
      E.tryPromise({
        try: () => serverDb.executeQuery<T>(queryFn),
        catch: (error) => 
          new DatabaseError({
            message: `Failed to execute custom query${options?.entity ? ` on ${options.entity}` : ''}`,
            operation: options?.operation || "query",
            entity: options?.entity || "unknown",
            cause: error
          })
      }).pipe(
        E.withSpan(`Database.execute${options?.entity ? `.${options.entity}` : ''}`),
        E.tap(() => E.annotateCurrentSpan("db.operation", options?.operation || "custom")),
        E.tap(() => options?.entity && E.annotateCurrentSpan("db.entity", options.entity))
      ),
  })),
}) {}
